<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RSLint docs</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> RSLint</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user/config.html"><strong aria-hidden="true">1.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="user/directives.html"><strong aria-hidden="true">1.2.</strong> Directives</a></li></ol></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">2.</strong> Dev Docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/project_layout.html"><strong aria-hidden="true">2.1.</strong> Project Layout</a></li><li class="chapter-item expanded "><a href="dev/rules.html"><strong aria-hidden="true">2.2.</strong> Rules</a></li><li class="chapter-item expanded "><a href="dev/syntax.html"><strong aria-hidden="true">2.3.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="dev/docgen.html"><strong aria-hidden="true">2.4.</strong> Docgen</a></li></ol></li><li class="chapter-item expanded "><a href="rules/index.html"><strong aria-hidden="true">3.</strong> Rules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/errors/index.html"><strong aria-hidden="true">3.1.</strong> errors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rules/errors/for-direction.html"><strong aria-hidden="true">3.1.1.</strong> for-direction</a></li><li class="chapter-item expanded "><a href="rules/errors/getter-return.html"><strong aria-hidden="true">3.1.2.</strong> getter-return</a></li><li class="chapter-item expanded "><a href="rules/errors/no-async-promise-executor.html"><strong aria-hidden="true">3.1.3.</strong> no-async-promise-executor</a></li><li class="chapter-item expanded "><a href="rules/errors/no-await-in-loop.html"><strong aria-hidden="true">3.1.4.</strong> no-await-in-loop</a></li><li class="chapter-item expanded "><a href="rules/errors/no-compare-neg-zero.html"><strong aria-hidden="true">3.1.5.</strong> no-compare-neg-zero</a></li><li class="chapter-item expanded "><a href="rules/errors/no-cond-assign.html"><strong aria-hidden="true">3.1.6.</strong> no-cond-assign</a></li><li class="chapter-item expanded "><a href="rules/errors/no-constant-condition.html"><strong aria-hidden="true">3.1.7.</strong> no-constant-condition</a></li><li class="chapter-item expanded "><a href="rules/errors/no-debugger.html"><strong aria-hidden="true">3.1.8.</strong> no-debugger</a></li><li class="chapter-item expanded "><a href="rules/errors/no-dupe-keys.html"><strong aria-hidden="true">3.1.9.</strong> no-dupe-keys</a></li><li class="chapter-item expanded "><a href="rules/errors/no-duplicate-cases.html"><strong aria-hidden="true">3.1.10.</strong> no-duplicate-cases</a></li><li class="chapter-item expanded "><a href="rules/errors/no-empty.html"><strong aria-hidden="true">3.1.11.</strong> no-empty</a></li><li class="chapter-item expanded "><a href="rules/errors/no-extra-boolean-cast.html"><strong aria-hidden="true">3.1.12.</strong> no-extra-boolean-cast</a></li><li class="chapter-item expanded "><a href="rules/errors/no-extra-semi.html"><strong aria-hidden="true">3.1.13.</strong> no-extra-semi</a></li><li class="chapter-item expanded "><a href="rules/errors/no-inner-declarations.html"><strong aria-hidden="true">3.1.14.</strong> no-inner-declarations</a></li><li class="chapter-item expanded "><a href="rules/errors/no-irregular-whitespace.html"><strong aria-hidden="true">3.1.15.</strong> no-irregular-whitespace</a></li><li class="chapter-item expanded "><a href="rules/errors/no-prototype-builtins.html"><strong aria-hidden="true">3.1.16.</strong> no-prototype-builtins</a></li><li class="chapter-item expanded "><a href="rules/errors/no-setter-return.html"><strong aria-hidden="true">3.1.17.</strong> no-setter-return</a></li><li class="chapter-item expanded "><a href="rules/errors/no-sparse-arrays.html"><strong aria-hidden="true">3.1.18.</strong> no-sparse-arrays</a></li><li class="chapter-item expanded "><a href="rules/errors/no-unexpected-multiline.html"><strong aria-hidden="true">3.1.19.</strong> no-unexpected-multiline</a></li><li class="chapter-item expanded "><a href="rules/errors/no-unsafe-finally.html"><strong aria-hidden="true">3.1.20.</strong> no-unsafe-finally</a></li><li class="chapter-item expanded "><a href="rules/errors/no-unsafe-negation.html"><strong aria-hidden="true">3.1.21.</strong> no-unsafe-negation</a></li><li class="chapter-item expanded "><a href="rules/errors/use-isnan.html"><strong aria-hidden="true">3.1.22.</strong> use-isnan</a></li><li class="chapter-item expanded "><a href="rules/errors/valid-typeof.html"><strong aria-hidden="true">3.1.23.</strong> valid-typeof</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RSLint docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rslint" id="rslint">RSLint</a></h1>
<p>RSLint is an extremely fast JavaScript linter written in Rust focusing on ease of use, customizability, and speed. RSLint
helps you find and fix error-prone productions in your code as well as enforce good practices.</p>
<h2><a class="header" href="#docs" id="docs">Docs</a></h2>
<p>You can also find documentation about individual rules <a href="./rules">here</a>. There are also dev docs <a href="./dev">here</a> if you are interested in contributing to RSLint or knowing more about how it works.</p>
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<p>You must have cargo installed on your machine, then git clone the repository, and either build the binary and run it, or use cargo run directly.</p>
<pre><code class="language-sh">git clone https://github.com/RDambrosio016/RSLint.git
cd RSLint
cargo run --release -- ./glob/pattern.js
</code></pre>
<p>You can also directly install the rslint cli:</p>
<pre><code class="language-sh">cargo install rslint_cli
rslint_cli ./glob/pattern.js
</code></pre>
<p>If you do not have rust installed you can find prebuilt binaries for every release <a href="https://github.com/RDambrosio016/RSLint/releases">here</a>.</p>
<h2><a class="header" href="#running-in-vsc" id="running-in-vsc">Running in VSC</a></h2>
<p>RSLint has a basic LSP and VSC extension, it is however not yet published as it is very early in development. If you would like to use it you
must first install the lsp in the project with <code>cargo install --path crates/rslint_lsp</code>. Then, open <code>editors/vscode</code> with visual studio code and press
<code>f5</code> to start a new vscode instance with the extension. Any <code>js</code> or <code>mjs</code> files you open will now be actively linted. The linter runs on the fly, not on save.</p>
<h2><a class="header" href="#note" id="note">Note</a></h2>
<p>⚠️ RSLint is still in early development, so expect bugs ⚠️</p>
<h1><a class="header" href="#linter-configuration" id="linter-configuration">Linter Configuration</a></h1>
<p>RSLint is fully configurable, you can configure the linter through a <code>rslintrc.toml</code> file in the linting directory.</p>
<h2><a class="header" href="#syntax" id="syntax">Syntax</a></h2>
<p>RSLint uses <a href="https://toml.io/en/">TOML</a> as its standard configuration format. TOML is a simple, minimal, human friendly format similar to INI.
TOML was chosen over JSON for clarity, simplicity, and ease of use.</p>
<p>Here are a few examples of a TOML configuration as opposed to a JSON configuration:</p>
<pre><code class="language-json">&quot;rules&quot;: {
  &quot;allow&quot;: [&quot;no-await-in-loop&quot;],
  &quot;groups&quot;: [&quot;errors&quot;],
  &quot;errors&quot;: {
    &quot;no-empty&quot;: { &quot;disallowEmptyFunction&quot;: true },
    &quot;for-direction&quot;: {}
  },
  &quot;warnings&quot;: {
    &quot;getter-return&quot;: {}
  }
}
</code></pre>
<p>TOML equivalent:</p>
<pre><code class="language-toml">[rules]
allow = [&quot;no-empty&quot;]
groups = [&quot;errors&quot;]

[rules.errors]
no-empty = { disallowEmptyFunction = true }
for-direction = {}

[rules.warnings]
getter-return = {}
</code></pre>
<p>TOML syntax also allows for:</p>
<pre><code class="language-toml">[rules]
allow = [&quot;no-empty&quot;]
groups = [&quot;errors&quot;]

[rules.errors]
for-direction = {}

[rules.errors.no-empty]
disallowEmptyFunction = true

[rules.warnings]
getter-return = {}
</code></pre>
<p>TOML further allows for comments using <code># This is a comment</code> which allows you to explain reasonings behind
configuration fields.</p>
<h2><a class="header" href="#rules" id="rules">Rules</a></h2>
<p>You can configure what rules the linter runs using the <code>rules</code> field.
The <code>rules</code> field can take 4 keys, these are:</p>
<ul>
<li><code>allow</code>: an array of strings of rules which are explicitly allowed and will not be run.</li>
<li><code>errors</code>: an object where each key is a rule name, and the value is the rule's configuration options (or <code>{}</code> if no config). These rules will be treated as errors.</li>
<li><code>warnings</code>: same as <code>errors</code> but the rules will be treated as warnings.</li>
<li><code>groups</code>: an array of strings where each string is the name of a <a href="user/./rules">rule group</a>. All of the rules of each group will be treated as errors.</li>
</ul>
<p>Rule names can be in any case, e.g. <code>no-empty</code>, <code>noEmpty</code>, <code>NoEmpty</code>, and <code>no_empty</code> all work. However it is strongly reccomended to keep a consistent case!</p>
<p>These fields above are listed in terms of precedence.</p>
<p>For instance:</p>
<pre><code class="language-toml">[rules]
allow = [&quot;no-empty&quot;]
groups = [&quot;errors&quot;]

[rules.errors]
no-empty = { disallowEmptyFunctions = true }

[rules.warnings]
no-empty = {}
</code></pre>
<p>In this case <code>no-empty</code> would not be run, because <code>allow</code> always takes precedence. If allow was not there then the <code>no-empty</code> in <code>rules.errors</code> would
be run. if that was not there then the configuration in <code>rules.warnings</code> would be used. if that was not there then the rule would be run at error level because it is included in <code>errors</code>.</p>
<p>The linter will warn you if a rule config is being ignored because of precedence.</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Enabling all rules in the <code>errors</code> group:</p>
<pre><code class="language-toml">[rules]
groups = [&quot;errors&quot;]
</code></pre>
<p>Enabling all rules in the <code>errors</code> group but allowing <code>no-empty</code>:</p>
<pre><code class="language-toml">[rules]
groups = [&quot;errors&quot;]
allow = [&quot;no-empty&quot;]
</code></pre>
<p>Enabling all rules in the <code>errors</code> group but making <code>no-empty</code> a warning without configuration:</p>
<pre><code class="language-toml">[rules]
groups = [&quot;errors&quot;]

[rules.warnings]
no-empty = {}
</code></pre>
<p>Enabling <code>no-empty</code> with a configuration and enabling <code>for-direction</code> as an error:</p>
<pre><code class="language-toml">[rules.errors]
for-direction = {}
no-empty = { disallowEmptyFunctions = true }
</code></pre>
<p>or</p>
<pre><code class="language-toml">[rules.errors]
for-direction = {}

[rules.errors.no-empty]
disallowEmptyFunctions = true
</code></pre>
<h1><a class="header" href="#directives" id="directives">Directives</a></h1>
<p>Directives are comments which are used to control the linter's behavior from inside source code files. Directives may contain multiple commands,
and may contain any comments after <code>--</code> to specify why the directive is needed. Directives placed before any statement or declaration apply to the entire file, and those placed on top of statements or declarations apply only to that node. </p>
<p>Each directive should start with <code>rslint-</code> followed by a command, you can include multiple commands by separating them with <code>-</code>. </p>
<h2><a class="header" href="#ignore-commands" id="ignore-commands">Ignore commands</a></h2>
<p><code>ignore</code> commands allow you to ignore rules for the entire file, ignore rules for a node, ignore all rules for a node, or ignore an entire file. Ignore commands are simply <code>ignore</code> followed by a comma separated list of rule names.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<p>Ignoring the entire file:</p>
<pre><code class="language-js">// rslint-ignore

if (true) {}
</code></pre>
<p>Ignoring a rule for the entire file:</p>
<pre><code class="language-js">// rslint-ignore no-empty

if (foo) {}
</code></pre>
<p>Ignoring a rule for a specific statement or declaration:</p>
<pre><code class="language-js">// rslint-ignore no-empty
if (foo) {}
</code></pre>
<p>Ignoring all rules for a statement or declaration:</p>
<pre><code class="language-js">// rslint-ignore
if (true) {}
</code></pre>
<h1><a class="header" href="#dev-docs" id="dev-docs">Dev Docs</a></h1>
<p>These docs are meant to help document how RSLint works and how some of its concepts work, as well as help new contributors get involved.</p>
<h1><a class="header" href="#project-layout" id="project-layout">Project Layout</a></h1>
<p>RSLint is a monorepo (workspace), this allows us to distinctly separate logic and redistibute some of that logic as crates.
The actual bulk of linting is done in <code>rslint_core</code>, which is where all rules are implemented.</p>
<h2><a class="header" href="#linting-flow" id="linting-flow">Linting Flow</a></h2>
<p>Linting consists of distinct steps, which are separated into crates to avoid a single messy crate.</p>
<p>This is a simplified summary of the linting process:</p>
<pre><code>CLI parsing --&gt; File walker --&gt; Lexing --&gt; Parsing --&gt; Linting --&gt; Result collection --&gt; Diagnostic emission
    |                                                     |
    v                                                     v
Config parsing                                      Scope analysis
</code></pre>
<h2><a class="header" href="#rslint_cli" id="rslint_cli">rslint_cli</a></h2>
<p>Linting starts with <a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_cli"><code>rslint_cli</code></a>. Its jobs include the following:</p>
<ul>
<li>CLI arg parsing</li>
<li>Configuration parsing</li>
<li>File loading</li>
<li>Calling the lint runner</li>
<li>Emitting results/diagnostics</li>
</ul>
<p>The crate starts by trying to load the configuration file, this is done by spawning a thread which will try to load
the <code>rslintrc.toml</code> file and returning a handle to it. Then it will instantiate the <code>FileWalker</code>, this is the structure
which manages loading files from disk, it does so concurrently by spawning one thread per file being loaded.</p>
<p>From then on it will collect the rules it needs to run from the config, and it will call the <code>lint_file</code> function from the <code>rslint_core</code> crate.</p>
<h2><a class="header" href="#rslint_core" id="rslint_core">rslint_core</a></h2>
<p>This is the crate where all the magic happens, it contains every rule plus general utilities. <code>rslint_core</code> should never know about CLI logic.
The point of separating the core linter logic and the cli logic is to allow rust users to run the linter on pieces of code without having to worry
about the overhead of CLI/binary logic.</p>
<p>The core structure (well, trait) of <code>rslint_core</code> is <code>CstRule</code>. <code>CstRule</code> is a trait describing a rule which is run on the concrete syntax tree of a single
file. A rule can operate on nodes, tokens, or the root node of a tree. You will notice there is no mention of a visitor anywhere, you can learn why <a href="dev/./syntax.html">here</a>.</p>
<p>It is <strong>very</strong> important that each rule be Send and Sync, because rules are run highly parallel. (the linter will eventually have a type of rule which is run on all of the CSTs of each file). Most rules run on nodes, therefore use <code>check_node</code>, however, some need to check the token or the root, which is why <code>check_token</code> and <code>check_root</code> exist.</p>
<p>As for running rules, the linter starts by taking the source code, and parsing it into a syntax tree using <a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_parser"><code>rslint_parser</code></a>. It then uses rayon to run every rule in the <code>CstRuleStore</code> in parallel. Syntax nodes are not thread safe because they are backed by an Rc, however we can pass a pointer to a green tree and reconstruct the root syntax node. For each descendant in the root node the linter runs each rule in parallel, each rule gets a new context instance, this instance will be used by the rule to attach diagnostics to it.</p>
<h2><a class="header" href="#rslint_lexer" id="rslint_lexer">rslint_lexer</a></h2>
<p><code>rslint_lexer</code> is a standard JavaScript lexer, it can also do ANSI syntax highlighting. The lexer is lookup table based, and it contains a decent amount of unsafe to make it stupidly fast, if you are working on it you should be quite careful and include safety comments for any unsafe usage.</p>
<h2><a class="header" href="#rslint_parser" id="rslint_parser">rslint_parser</a></h2>
<p>The parser is the heart of a linter, you can find a complete list of features but the most distinguished ones are:</p>
<ul>
<li>Speed</li>
<li>Complete error recovery</li>
<li>Simple parsing without explicitly handling AST nodes</li>
<li>Rich utilities</li>
<li>(WIP) incremental reparsing</li>
</ul>
<p>The concepts for the parser and the syntax it produces are taken from <a href="https://github.com/rust-analyzer/rust-analyzer">rust analyzer</a> and its syntax library, <a href="https://docs.rs/rowan/0.10.0/rowan/index.html">rowan</a>. You can read about the syntax concepts <a href="dev/./syntax.html">here</a> and in the <a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md">rust analyzer docs</a>.</p>
<p>The parser is by no means tied to the linter, it knows nothing about the linter, therefore you are free to reuse it for any projects.</p>
<h2><a class="header" href="#rslint_scope" id="rslint_scope">rslint_scope</a></h2>
<p><code>rslint_scope</code> is the scope analysis library. It produces a scope which contains items such as declared variables, variable refs, and child scopes. The scope analysis library tries to be as detailed as possible, most items are wrapped in Rcs or Weaks which allow it to refer back to declarations or parent scopes.</p>
<h1><a class="header" href="#implementing-rules-and-groups" id="implementing-rules-and-groups">Implementing rules and groups</a></h1>
<h2><a class="header" href="#implementing-a-rule" id="implementing-a-rule">Implementing a rule</a></h2>
<p>Let's walk through how we would implement a rule, for this example let's implement eslint's <code>no-extra-semi</code>.</p>
<p>First, we must decide the correct group for the rule, we will place it in <code>errors</code> for this example.
Therefore, lets create a file under <code>rslint_core/src/groups/errors</code> called <code>no_extra_semi.rs</code>.</p>
<p>Then, go to the <code>mod.rs</code> file of the group, and at the end of the <code>group!</code> declaration add the rule:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>no_extra_semi::NoExtraSemi
<span class="boring">}
</span></code></pre></pre>
<p>Don't worry if you get errors, theyll be fixed soon.</p>
<p>RSLint defines a <a href="https://github.com/RDambrosio016/RSLint/blob/master/crates/rslint_core/src/rule_prelude.rs">rule_prelude</a> module, which contains commonly used
items by rules, which saves a ton of painful imports.</p>
<p>the prelude includes a <code>declare_lint</code> macro, this macro is a way of easily declaring a new rule, it is also used by
the docgen script to generate user facing documentation. The macro starts with attributes for the struct generated for the rule.
You'll have to either derive default or implement it yourself. These attributes can also include a doc comment which will be used by
docgen for the user facing docs, we will get back to that later.</p>
<p>The next item is just the struct name, which is just the rule name but pascal case, <code>NoExtraSemi</code> for this example. Then the name of the group,
<code>errors</code> in this case. And finally, the kebab case code for this rule, this must be unique, <code>no-extra-semi</code> in this case.</p>
<p>For this rule we won't define any config fields, but you may do so after the code, including any private fields for the struct. Each config field can take attributes including doc comments which will be used by docgen for the user facing docs (to make a config fields table). Don't worry about using camel case for the config fields, the macro will automatically rename all fields to camel case.</p>
<p>The lint declaration would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint! {
  #[derive(Default)]
  NoExtraSemi,
  errors,
  &quot;no-extra-semi&quot;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-cstrule" id="implementing-cstrule">Implementing CstRule</a></h3>
<p>The next step is to implement the <code>CstRule</code> trait, youll have to first use the <code>#[typetag::serde]</code> attribute on the impl. The reasoning behind this is rslint does configuration by deserializing trait objects themselves, which can only be done with typetag:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  /* */
}
<span class="boring">}
</span></code></pre></pre>
<p>We want to check each <code>EmptyStatement</code>, therefore we will want to implement <code>check_node</code> in <code>CstRule</code>. The function signature is pretty simple, it takes a reference to the node, a mutable context, and returns a <code>Option&lt;()&gt;</code>. The context is what we will add diagnostics to, and the return type is simply a hack to be able to return early with <code>?</code>, since everything in the AST is optional it can get a little messy without it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  fn check_node(&amp;self, node: &amp;SyntaxNode, ctx: &amp;mut RuleCtx) -&gt; Option&lt;()&gt; {
    /* */
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>We simply want to check any empty statement node, this is very simple, we can just add an if statement checking if the node kind is <code>SyntaxKind::EMPTY_STMT</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  fn check_node(&amp;self, node: &amp;SyntaxNode, ctx: &amp;mut RuleCtx) -&gt; Option&lt;()&gt; {
    if node.kind() == SyntaxKind::EMPTY_STMT {
      /* */
    }
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is where untyped nodes shine, we want to allow empty statements if the parent is a loop, labelled statement, or with statement. We can very easily do this by making a const of syntax kinds we will check. <code>SyntaxKind</code> is an enum which lists every possible kind of node or token. For convenience we will add a <code>use SyntaxKind::*</code>, all syntax kinds are screaming snake case, so there should not be any conflicts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ALLOWED: [SyntaxKind; 8] = [
  FOR_STMT,
  FOR_IN_STMT,
  FOR_OF_STMT,
  WHILE_STMT,
  DO_WHILE_STMT,
  IF_STMT,
  LABELLED_STMT,
  WITH_STMT
];
<span class="boring">}
</span></code></pre></pre>
<p>We can then simply check if the parent is allowed using <code>map_or</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  fn check_node(&amp;self, node: &amp;SyntaxNode, ctx: &amp;mut RuleCtx) -&gt; Option&lt;()&gt; {
    if node.kind() == SyntaxKind::EMPTY_STMT &amp;&amp; node.parent().map_or(true, |parent| !ALLOWED.contains(&amp;parent.kind())) {
      /* */
    }
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>For reporting diagnostics we can use the <code>DiagnosticBuilder</code>. <code>ctx</code> has a util method for making a new builder called <code>ctx.err()</code>. The method
takes the code of the diagnostic (the rule code or <code>self.name()</code> in our case), and the primary message. For the primary message we will use <code>Unnecessary semicolon</code>. The primary message should say what is wrong in full.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  fn check_node(&amp;self, node: &amp;SyntaxNode, ctx: &amp;mut RuleCtx) -&gt; Option&lt;()&gt; {
    if node.kind() == SyntaxKind::EMPTY_STMT &amp;&amp; node.parent().map_or(true, |parent| !ALLOWED.contains(&amp;parent.kind())) {
      let err = ctx.err(self.name(), &quot;Unnecessary semicolon&quot;);
      /* */
    }
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Simple errors with only a message are boring and unhelpful, we want to point to the location of the error, and add notes and labels saying what is wrong. We can do this using the <code>primary</code>, <code>secondary</code>, and <code>note</code> methods on the builder. <code>primary</code> and <code>secondary</code> take a range for the label and a message. <code>primary</code> is the primary (red) label and location of the error, there should only be one of these. <code>secondary</code> labels are blue labels which provide more context, these are used for explaining more complex errors or providing context, if you want to see a practical use of them look at <code>for-direction</code>.</p>
<p>For this example let's add a primary label which tells the user to delete the semicolon:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[typetag::serde]
impl CstRule for NoExtraSemi {
  fn check_node(&amp;self, node: &amp;SyntaxNode, ctx: &amp;mut RuleCtx) -&gt; Option&lt;()&gt; {
    if node.kind() == SyntaxKind::EMPTY_STMT &amp;&amp; node.parent().map_or(true, |parent| !ALLOWED.contains(&amp;parent.kind())) {
      let err = ctx.err(self.name(), &quot;Unnecessary semicolon&quot;)
        .primary(node.trimmed_range(), &quot;help: delete this semicolon&quot;);

      ctx.add_err(err);
    }
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it for the implementation!</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>For testing you can use the <code>rule_tests!</code> macro, which uses straight forward syntax. It starts with the rule to check, then an <code>err: {}</code> block, and an <code>ok: {}</code> block. Each block consists of comma separated string literals which will either be checked for linting failure or for linting success.</p>
<p>Each test will be used in <code>more incorrect examples</code> and <code>more correct examples</code> section in user facing docs by docgen. You can put <code>/// ignore</code> above the literal
to have docgen not show it. Don't worry about indentation or trailing or leading whitespace, docgen will fix both of those issues when generating.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rule_tests! {
  NoExtraSemi::default(),
  err: {
    /// ignore
    &quot;;&quot;,
    &quot;
    if (foo) {
      ;
    }
    &quot;,
    &quot;
    class Foo {
      ;
    }
    &quot;,
    &quot;class Foo extends Bar {
      constructor() {};
    }
    &quot;
  },
  ok: {
    &quot;
    class Foo {}
    &quot;
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>For documentation, it is done through the lint_declaration macro. All you need to do is add a doc comment before the struct name. Documentation is decently large, so you should generally use <code>/** */</code> comments over <code>///</code> comments. You must include a small description of the rule, then a newline for docgen to use for the top level rules table for each group. Each rule should also generally include an <code>## Invalid Code Examples</code> header.</p>
<p>let's add docs for our rule:</p>
<pre><code class="language-rs">declare_lint! {
  /**
  Disallow unneeded semicolons.

  Unneeded semicolons are often caused by typing mistakes, while this is not an error, it
  can cause confusion when reading the code. This rule disallows empty statements (extra semicolons).

  ## Invalid Code Examples

  ```ignore
  if (foo) {
    ;
  }
  ```

  ```ignore
  class Foo {
    constructor() {};
  }
  ```
  */
  #[derive(Default)]
  NoExtraSemi,
  errors,
  &quot;no-extra-semi&quot;
}
</code></pre>
<p>And finally, run the docgen with <code>cargo docgen</code> or <code>cargo xtask docgen</code>. This will create the appropriate file in the rules docs and update readmes.</p>
<h1><a class="header" href="#untyped-syntax-nodes" id="untyped-syntax-nodes">Untyped syntax nodes</a></h1>
<p>Traditionally, linters operate directly on an AST. This works fine for most cases if you have a visitor, however, it is too constrained for a powerful linter. ASTs have very significant downsides which include: </p>
<ul>
<li>Often expensive to clone and pass around </li>
<li>Node traversal is impossible without runtime typing, and even with runtime typing it is extremely constrained. </li>
<li>No straightforward way to obtain individual tokens or child nodes</li>
<li>Lossy, no way to cleanly and efficiently represent whitespace inside of them, which is crucial for stylistic linting.</li>
<li>Require explicit handling of their structures in the parser</li>
<li>Mutable, which is fine for most cases but you really do not want mutable trees for static analysis in a language without a GC. </li>
<li>No way to go back to source without a formatter or expensive storage of original source code</li>
<li>Makes error recovery for a parser very constrained </li>
</ul>
<p>To counteract this, RSLint uses a significantly different representation for ASTs, which are called green trees/syntax nodes. At the core, a tree
is immutable and is represented by an immutable &quot;green tree&quot;, a tree consists of green nodes which contain children, which can be green nodes and green tokens. <a href="https://docs.rs/rowan/0.10.0/rowan/api/struct.SyntaxNode.html">Syntax nodes</a> are wrappers consisting of a <code>Rc</code> housing some node data in the green tree. <a href="https://docs.rs/rowan/0.10.0/rowan/api/struct.SyntaxToken.html">Syntax tokens</a> are the same thing but for tokens in the green tree. This means our AST and nodes are all immutable, it also means we can cheaply clone nodes and tokens and pass them around to individual analyzers (e.g. scope analysis) and functions without worrying about memory usage. Nodes and tokens are untyped, which means traversal of the syntax tree from a token is dead simple as you can see from the documentation on syntax node. This gets rid of the issue of complex node traversal being nearly impossible in typed ASTs.</p>
<p>Well does this really make a difference you might be asking. It sure does! for example, the deno_lint (a traditional AST based linter) logic for <a href="dev/../rules/errors/no-await-in-loop.html">no-await-in-loop</a> is <a href="https://github.com/denoland/deno_lint/blob/master/src/rules/no_await_in_loop.rs">235 lines</a>, while the rslint logic is <a href="https://github.com/RDambrosio016/RSLint/blob/dev/rslint_core/src/groups/errors/no_await_in_loop.rs">35 lines</a>. This is because deno lint cannot get the ancestors of an ast node so it has to take a recursive top-down approach, handling every possible async function case. Instead, with untyped nodes we can freely get the ancestors and check them recursively. </p>
<p>Obviously, linting also requires typed structures, in this case, typed AST nodes are simple wrappers on top of a single syntax node. AST nodes simply define functions which traverse the node and get specific productions, which are then casted to another node. The conversion to and from untyped to typed is zero cost, which is great for a parallelized linter which needs to share AST nodes. Another thing about AST nodes is each function for properties returns an optional value (or iterator), because unlike other linters, rslint can fully recover from pretty much all parser errors and still lint the resulting tree. </p>
<p>Moreover, untyped nodes allow us to grab specific parts of a node, which is particularly important for rslint because it tries to emit the best diagnostics possible, which involves labeling specific parts.</p>
<p>And finally, untyped nodes can be lowered down to both lossy and lossless tokens, which allow us to do many cool things not doable without storing all tokens, which is expensive without interning (green trees do this automatically). These include:</p>
<ul>
<li>Lexical equality, which is better than string equality, because according to string equality, <code>foo .bar</code> and <code>foo.bar</code> are different </li>
<li>Lexical syntax highlighting (you can see this in action using <code>rslint explain some-rule-here</code>) </li>
<li>Lexical checking, such as being able to check the function name with <code>&amp;[&quot;Object&quot;, &quot;.&quot;, &quot;defineProperty&quot;]</code> </li>
<li>Easy whitespace checking</li>
<li>Easy comment checking</li>
</ul>
<h1><a class="header" href="#docgen" id="docgen">Docgen</a></h1>
<p>Documentation for the rules folder is not manually written, documentation is written as rust doc comments
in source files (in the lint declaration). And a <a href="https://github.com/RDambrosio016/RSLint/blob/master/xtask/src/docgen/mod.rs">docgen script</a> is used to generate the user facing docs.
The docgen script allows us to make rustdoc documentation, as well as user facing documentation automatically.</p>
<p>Docgen goes through a few steps to collect docs:</p>
<ul>
<li>The script crawls the <a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups">groups directory</a>, for every group it will:<br />
_ Collect the group name by looking at the <code>group!</code> invocation in <code>mod.rs</code><br />
_ For each rule file it will then:<br />
_ Collect the <code>declare_lint!</code> invocation, from this it grabs the main documentation, replacing all <code>ignore</code> code blocks with <code>js</code>.
it will also collect any public config fields and their corresponding documentation.<br />
_ Collect the possible <code>rule_tests!</code> invocation, for each err and ok test, if it is not marked with <code>/// ignore</code> then it<br />
will be used in <code>More invalid examples</code> and <code>More valid examples</code> sections.<br />
_ Append the rule name to the top of the file.<br />
_ Append the main documentation.<br />
_ Build a table of config fields (if any).<br />
_ Append any <code>More invalid examples</code> and <code>More valid examples</code> sections built from tests.<br />
_ Append a hyperlink to the source code<br />
_ Generate a README for the group, with a table of all the rules, including the first sentence of each rule's doc as a description.<br />
it also links each rule's markdown file as a hyperlink.<br />
* The script collects all groups which have been collected and generates this top level document with a table of the groups
which you might have seen right above ^^</li>
</ul>
<p>You can run the docgen with either <code>cargo docgen</code> or <code>cargo xtask codegen</code>.</p>
<!--
generated docs file, do not edit by hand, see xtask/docgen 
-->
<p>User documentation for RSLint rules. RSLint groups rules by their scope, each group 
has a specific scope. Grouping rules allows RSLint to distinctly group rules for a better project structure, 
as well as allowing users to disable a whole group of rules.</p>
<h2><a class="header" href="#groups" id="groups">Groups</a></h2>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="rules/./errors">errors</a></td><td>Rules which relate to productions which are almost always erroneous or cause<br>unexpected behavior.</td></tr>
</tbody></table>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#errors" id="errors">Errors</a></h1>
<p>Rules which relate to productions which are almost always erroneous or cause
unexpected behavior.</p>
<h2><a class="header" href="#rules-1" id="rules-1">Rules</a></h2>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="rules/errors/./for-direction.html">for-direction</a></td><td>Disallow for loops which update their counter in the wrong direction.</td></tr>
<tr><td><a href="rules/errors/./getter-return.html">getter-return</a></td><td>Disallow getter properties which do not always return a value.</td></tr>
<tr><td><a href="rules/errors/./no-async-promise-executor.html">no-async-promise-executor</a></td><td>Disallow async functions as promise executors.</td></tr>
<tr><td><a href="rules/errors/./no-await-in-loop.html">no-await-in-loop</a></td><td>Disallow await inside of loops.</td></tr>
<tr><td><a href="rules/errors/./no-compare-neg-zero.html">no-compare-neg-zero</a></td><td>Disallow comparison against <code>-0</code> which yields unexpected behavior.</td></tr>
<tr><td><a href="rules/errors/./no-cond-assign.html">no-cond-assign</a></td><td>Forbid the use of assignment expressions in conditions which may yield unwanted behavior.</td></tr>
<tr><td><a href="rules/errors/./no-constant-condition.html">no-constant-condition</a></td><td>Disallow constant conditions which always yield one result.</td></tr>
<tr><td><a href="rules/errors/./no-debugger.html">no-debugger</a></td><td>Disallow the use of debugger statements.</td></tr>
<tr><td><a href="rules/errors/./no-dupe-keys.html">no-dupe-keys</a></td><td>Disallow duplicate keys in object literals.</td></tr>
<tr><td><a href="rules/errors/./no-duplicate-cases.html">no-duplicate-cases</a></td><td>Disallow duplicate test cases in <code>switch</code> statements.</td></tr>
<tr><td><a href="rules/errors/./no-empty.html">no-empty</a></td><td>Disallow empty block statements.</td></tr>
<tr><td><a href="rules/errors/./no-extra-boolean-cast.html">no-extra-boolean-cast</a></td><td>Disallow unnecessary boolean casts.</td></tr>
<tr><td><a href="rules/errors/./no-extra-semi.html">no-extra-semi</a></td><td>Disallow unneeded semicolons.</td></tr>
<tr><td><a href="rules/errors/./no-inner-declarations.html">no-inner-declarations</a></td><td>Disallow variable and function declarations in nested blocks.</td></tr>
<tr><td><a href="rules/errors/./no-irregular-whitespace.html">no-irregular-whitespace</a></td><td>Disallow weird/irregular whitespace.</td></tr>
<tr><td><a href="rules/errors/./no-prototype-builtins.html">no-prototype-builtins</a></td><td>Disallow direct use of <code>Object.prototype</code> builtins directly.</td></tr>
<tr><td><a href="rules/errors/./no-setter-return.html">no-setter-return</a></td><td>Disallow setters to return values.</td></tr>
<tr><td><a href="rules/errors/./no-sparse-arrays.html">no-sparse-arrays</a></td><td>Disallow sparse arrays.</td></tr>
<tr><td><a href="rules/errors/./no-unexpected-multiline.html">no-unexpected-multiline</a></td><td>Disallow confusing newlines in expressions.</td></tr>
<tr><td><a href="rules/errors/./no-unsafe-finally.html">no-unsafe-finally</a></td><td>Forbid the use of unsafe control flow statements in try and catch blocks.</td></tr>
<tr><td><a href="rules/errors/./no-unsafe-negation.html">no-unsafe-negation</a></td><td>Deny the use of <code>!</code> on the left hand side of an <code>instanceof</code> or <code>in</code> expression where it is ambiguous.</td></tr>
<tr><td><a href="rules/errors/./use-isnan.html">use-isnan</a></td><td>Disallow incorrect comparisons against <code>NaN</code>.</td></tr>
<tr><td><a href="rules/errors/./valid-typeof.html">valid-typeof</a></td><td>Enforce the use of valid string literals in a <code>typeof</code> comparison.</td></tr>
</tbody></table>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#for-direction" id="for-direction">for-direction</a></h1>
<p>Disallow for loops which update their counter in the wrong direction.</p>
<p>A for loop with a counter may update its value in the wrong direction. that is to say, if i made
a counter with a value of <code>0</code>, if the for statement checked if <code>counter &lt; 10</code> and the update went <code>counter--</code>,
that loop would be infinite. This is because <code>counter</code> will never be smaller than <code>10</code> because <code>counter--</code> always
yields a value smaller than 10. A for loop which does this is almost always a bug because it is either
unreachable or infinite.</p>
<h2><a class="header" href="#incorrect-code-examples" id="incorrect-code-examples">Incorrect Code Examples</a></h2>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i--) {
    /* infinite loop */
}
</code></pre>
<pre><code class="language-js">for (var i = 10; i &gt;= 20; i++) {
    /* unreachable */
}
</code></pre>
<h2><a class="header" href="#correct-code-examples" id="correct-code-examples">Correct Code Examples</a></h2>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {

}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i--) {}
</code></pre>
<pre><code class="language-js">for(let i = 0; i &lt; 2; i--) {}
</code></pre>
<pre><code class="language-js">for(let i = 0; i &lt;= 2; i += -1) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt;= 0; i -= -1) {}
</code></pre>
<pre><code class="language-js">for(let i = 0; i &lt; 2; i -= 1) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt; 2; i++) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt; 2; i += 1) {}
</code></pre>
<pre><code class="language-js">for(let i = 5n; i &lt; 2; i--) {}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt; 2; i -= 1) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt;= 0; i -= 1) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt; 2; i += -1) {}
</code></pre>
<pre><code class="language-js">for(let i = 2; i &gt;= 0; i += -1) {}
</code></pre>
<pre><code class="language-js">for(let i = 0; i &lt; 3;) {}
</code></pre>
<pre><code class="language-js">for(let i = 5; i &lt; 2; i |= 2) {}
</code></pre>
<pre><code class="language-js">for(let i = 5n; i &lt; 2n; i &amp;= 2) {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/for_direction.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#getter-return" id="getter-return">getter-return</a></h1>
<p>Disallow getter properties which do not always return a value.</p>
<p>Getters are special properties introduced in ES5 which call a function when a property is accessed.
The value returned will be the value returned for the property access:</p>
<pre><code class="language-js">let obj = {
    // Using object literal syntax
    get foo() {
        return 5;
    }
}

// Using the defineProperty function
Object.defineProperty(obj, &quot;foo&quot;, {
    get: function() {
        return 5;
    }
})
</code></pre>
<p>Getters are expected to return a value, it is a bad practice to use getters to run some function
without a return. This rule makes sure that does not happen and enforces a getter always returns a value.</p>
<h2><a class="header" href="#incorrect-code-examples-1" id="incorrect-code-examples-1">Incorrect code examples</a></h2>
<pre><code class="language-js">// The getter does not always return a value, it would not return anything
// if bar is falsey
let obj = {
    get foo() {
        if (bar) {
            return foo;
        }
    }
}
</code></pre>
<h2><a class="header" href="#correct-code-examples-1" id="correct-code-examples-1">Correct code examples</a></h2>
<pre><code class="language-js">// The getter always returns a value
let obj = {
    get foo() {
        if (bar) {
            return foo;
        } else {
            return bar;
        }
    }
}
</code></pre>
<h2><a class="header" href="#config" id="config">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>allowImplicit</code></td><td>bool</td><td>Whether to allow implicitly returning undefined with <code>return;</code>.<br><code>true</code> by default.</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">let foo = {
    get bar() {
        
    }
}
</code></pre>
<pre><code class="language-js">let bar = {
    get foo() {
        if (bar) {
            return bar;
        }
    }
}
</code></pre>
<pre><code class="language-js">let bar = {
    get foo() {
        switch (bar) {
            case 5:
            case 6:
            if (bar) {
                return 5;
            }
        }
    }
}
</code></pre>
<pre><code class="language-js">let bar = {
    get foo() {
        if (bar) {

        } else {
            return foo;
        }
    }
}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">let bar = {
    get foo() {
        return bar;
    }
}
</code></pre>
<pre><code class="language-js">let bar = {
    get foo() {
        if(bar) {
            if (bar) {
                return foo;
            } else {
                return 6;
            }
        } else {
            return 7;
        }
    }
}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/getter_return.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-async-promise-executor" id="no-async-promise-executor">no-async-promise-executor</a></h1>
<p>Disallow async functions as promise executors.</p>
<p>Promise executors are special functions inside <code>new Promise()</code> constructors which take a <code>resolve</code> and
<code>reject</code> parameter to resolve or reject the promise. The function is a normal function therefore it could be
an async function. However this is usually wrong because:
- Any errors thrown by the function are lost.
- It usually means the new promise is unnecessary.</p>
<h2><a class="header" href="#incorrect-code-examples-2" id="incorrect-code-examples-2">Incorrect code examples</a></h2>
<pre><code class="language-js">let foo = new Promise(async (resolve, reject) =&gt; {
    doSomething(bar, (err, res)) =&gt; {
       /* */
    });
});
</code></pre>
<pre><code class="language-js">let foo = new Promise(async function(resolve, reject) =&gt; {
    /* */
});
</code></pre>
<h2><a class="header" href="#correct-code-examples-2" id="correct-code-examples-2">Correct code examples</a></h2>
<p>Use a normal non-async function.</p>
<pre><code class="language-js">let foo = new Promise(function(resolve, reject) =&gt; {
    /* */
})
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">new Promise(async () =&gt; {})
</code></pre>
<pre><code class="language-js">new Promise(async function*() {})
</code></pre>
<pre><code class="language-js">new Promise(async function() {}, foo)
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">new Promise(() =&gt; {})
</code></pre>
<pre><code class="language-js">new Promise(function foo() {}, foo)
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_async_promise_executor.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-await-in-loop" id="no-await-in-loop">no-await-in-loop</a></h1>
<p>Disallow await inside of loops.</p>
<p>You may want to <code>await</code> a promise until it is fulfilled or rejected, inside of loops. In such cases, to take
full advantage of concurrency, you should <strong>not</strong> <code>await</code> the promise in every iteration, otherwise your async
operations will be executed serially.
Generally it is recommended that you create all promises, then use <code>Promise.all</code> for them. This way your async
operations will be performed concurrently.</p>
<h2><a class="header" href="#incorrect-code-exapmles" id="incorrect-code-exapmles">Incorrect Code Exapmles</a></h2>
<pre><code class="language-js">async function foo(xs) {
    const results = [];
    for (const x of xs) {
        // iteration does not proceed until `bar(x)` completes
        results.push(await bar(x));
    }
    return baz(results);
}
</code></pre>
<h2><a class="header" href="#correct-code-examples-3" id="correct-code-examples-3">Correct Code Examples</a></h2>
<pre><code class="language-js">async function foo(xs) {
    const results = [];
    for (const x of xs) {
        // push a promise to the array; it does not prevent the iteration
        results.push(bar(x));
    }
    // we wait for all the promises concurrently
    return baz(await Promise.all(results));
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">async function foo() {
    const res = [];
    for(var i = 1; i &lt; 20; i++) {
        res.push(await i);
    }
}
</code></pre>
<pre><code class="language-js">async () =&gt; {
    while(true) {
        await i;
    }
}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_await_in_loop.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-compare-neg-zero" id="no-compare-neg-zero">no-compare-neg-zero</a></h1>
<p>Disallow comparison against <code>-0</code> which yields unexpected behavior.</p>
<p>Comparison against <code>-0</code> causes unwanted behavior because it passes for both <code>-0</code> and <code>+0</code>.
That is, <code>x == -0</code> and <code>x == +0</code> both pass under the same circumstances. If a user wishes
to compare against <code>-0</code> they should use <code>Object.is(x, -0)</code>.</p>
<h2><a class="header" href="#incorrect-code-examples-3" id="incorrect-code-examples-3">Incorrect Code Examples</a></h2>
<pre><code class="language-js">if (x === -0) {
       // ^^ this comparison works for both -0 and +0
}
</code></pre>
<h2><a class="header" href="#correct-code-examples-4" id="correct-code-examples-4">Correct code examples</a></h2>
<pre><code class="language-js">if (x === 0) {
    /* */
}
</code></pre>
<pre><code class="language-js">if (Object.is(x, -0)) {
    /* */
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">x == -0
</code></pre>
<pre><code class="language-js">x != -0
</code></pre>
<pre><code class="language-js">x === -0
</code></pre>
<pre><code class="language-js">-0 === -0
</code></pre>
<pre><code class="language-js">-0 == x
</code></pre>
<pre><code class="language-js">-0 &gt;= 1
</code></pre>
<pre><code class="language-js">x &lt; -0
</code></pre>
<pre><code class="language-js">x !== -0
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">x === 0
</code></pre>
<pre><code class="language-js">0 === 0
</code></pre>
<pre><code class="language-js">Object.is(x, -0)
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_compare_neg_zero.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-cond-assign" id="no-cond-assign">no-cond-assign</a></h1>
<p>Forbid the use of assignment expressions in conditions which may yield unwanted behavior.</p>
<p>Assignment expressions return the value assigned:</p>
<pre><code class="language-js">let foo = 5;

console.log(foo = 8); // 8
console.log(foo += 4) // foo + 4 (12 in this case)
</code></pre>
<p>Users often make a typo and end up using <code>=</code> instead of <code>==</code> or <code>===</code> in conditions in statements
like <code>if</code>, <code>while</code>, <code>do_while</code>, and <code>for</code>. This is erroneous and is most likely unwanted behavior
since the condition used will actually be the value assigned.</p>
<h2><a class="header" href="#incorrect-code-examples-4" id="incorrect-code-examples-4">Incorrect Code Examples</a></h2>
<pre><code class="language-js">let foo = 5;

if (foo = 6) {
//      ^^^ assignments return the value assigned, therefore the condition checks `6`
//          `6` is always truthy, therefore the if statement always runs even if we dont want it to.

} else {}
//^^^^ it makes this else unreachable

foo // 6
</code></pre>
<h2><a class="header" href="#config-1" id="config-1">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>allowParens</code></td><td>bool</td><td>Allow an assignment if they are enclosed in parentheses to allow<br>things like reassigning a variable.</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">if (foo = 54) {}
</code></pre>
<pre><code class="language-js">while (foo = 1) {}
</code></pre>
<pre><code class="language-js">do { /* */ } while (bar = 1)
</code></pre>
<pre><code class="language-js">for(;foo = 4; bar) {}
</code></pre>
<pre><code class="language-js">if (bar = 5 ? foo : bar) {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_cond_assign.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-constant-condition" id="no-constant-condition">no-constant-condition</a></h1>
<p>Disallow constant conditions which always yield one result.</p>
<p>Constant conditions such as <code>if (true) {}</code> are almost always a mistake. Constant
conditions always yield a single result which almost always ends up in unwanted behavior.
This rule is aimed at catching those conditions in <code>if</code>, <code>do while</code>, <code>while</code>, and <code>for</code> statements, as well as
conditional expressions.</p>
<h2><a class="header" href="#incorrect-code-examples-5" id="incorrect-code-examples-5">Incorrect Code Examples</a></h2>
<pre><code class="language-js">if (true) {
    //    ^ this block is always used
} else {
//^^^^ this else block is unreachable
}
</code></pre>
<pre><code class="language-js">// This loop endlessly runs
for(foo = 5; 5; foo++) {

}
</code></pre>
<h2><a class="header" href="#correct-code-examples-5" id="correct-code-examples-5">Correct Code Examples</a></h2>
<pre><code class="language-js">if (foo) {
    /* */
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">if(6) {}
</code></pre>
<pre><code class="language-js">if(6 - 7 || 3 ? 7 &amp;&amp; 2 : NaN + NaN || 2) {}
</code></pre>
<pre><code class="language-js">if (true) {}
</code></pre>
<pre><code class="language-js">if (NaN) {} else {}
</code></pre>
<pre><code class="language-js">6 + 2 ? false : NaN
</code></pre>
<pre><code class="language-js">false ? false : false ? false : false
</code></pre>
<pre><code class="language-js">while (true) {}
</code></pre>
<pre><code class="language-js">do { /* */ } while (NaN ? NaN : true)
</code></pre>
<pre><code class="language-js">do { } while (NaN ? Infinity : true)
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">if (foo) {}
</code></pre>
<pre><code class="language-js">if (false &gt; foo) {} else {}
</code></pre>
<pre><code class="language-js">if (foo ? NaN : Infinity) {}
</code></pre>
<pre><code class="language-js">do {} while (foo + 6)
</code></pre>
<pre><code class="language-js">for(var i = 5; foo; i++) {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_constant_condition.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-debugger" id="no-debugger">no-debugger</a></h1>
<p>Disallow the use of debugger statements.</p>
<p><code>debugger</code> statements are used to tell the environment executing the code to start an appropriate
debugger. These statements are rendered useless by modern IDEs which have built in breakpoint support.
Having them in production code is erroneous as it will tell the browser to stop running and open a debugger.</p>
<h2><a class="header" href="#invalid-code-examples" id="invalid-code-examples">Invalid Code Examples</a></h2>
<pre><code class="language-js">function doSomething() {
    debugger;
    doSomethingElse();
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">debugger
</code></pre>
<pre><code class="language-js">debugger;
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_debugger.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-dupe-keys" id="no-dupe-keys">no-dupe-keys</a></h1>
<p>Disallow duplicate keys in object literals.</p>
<p>Object literals allow keys to be declared multiple times, however this causes unwanted
behavior by shadowing the first declaration.</p>
<h2><a class="header" href="#invalid-code-examples-1" id="invalid-code-examples-1">Invalid Code Examples</a></h2>
<pre><code class="language-js">let foo = {
    bar: 1,
    baz: 2,
    bar: 3
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">let foo = {
    bar,
    baz,
    get bar() {

    }
}
</code></pre>
<pre><code class="language-js">let foo = {
    get bar() {

    },
    set bar(foo)  {

    }
}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">let foo = {
    bar: {
        bar: {},
        baz: 5
    },
    baz: {}
}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_dupe_keys.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-duplicate-cases" id="no-duplicate-cases">no-duplicate-cases</a></h1>
<p>Disallow duplicate test cases in <code>switch</code> statements.</p>
<p><code>switch</code> statement clauses can freely have duplicate tests, however this is almost always a mistake, because
the second case is unreachable. It is likely that the programmer copied a case clause but did not change the test for it.</p>
<h2><a class="header" href="#invalid-code-examples-2" id="invalid-code-examples-2">Invalid Code Examples</a></h2>
<pre><code class="language-js">switch (a) {
    case 1:
        break;
    case 2:
        break;
    case 1:
        break;
    default:
        break;
}
</code></pre>
<pre><code class="language-js">switch (a) {
    case foo.bar:
        break;

    case foo . bar:
        break;
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">switch (foo) {
    case foo. bar:
    break;

    case foo.bar:
    break;
}
</code></pre>
<pre><code class="language-js">switch foo {
    case 5:
    break;

    case 6:
    break;

    case 5:
    break;
}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_duplicate_cases.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-empty" id="no-empty">no-empty</a></h1>
<p>Disallow empty block statements.</p>
<p>Block statements with nothing in them are very common when refactoring, however
they can get confusing really quickly. This rule reports empty block statements and empty switch
case blocks if they do not have a comment.</p>
<h2><a class="header" href="#invalid-code-examples-3" id="invalid-code-examples-3">Invalid Code Examples</a></h2>
<pre><code class="language-js">{}
</code></pre>
<pre><code class="language-js">if (foo) {

}
</code></pre>
<h2><a class="header" href="#correct-code-examples-6" id="correct-code-examples-6">Correct Code Examples</a></h2>
<pre><code class="language-js">if (foo) {
    /* todo */
}
</code></pre>
<h2><a class="header" href="#config-2" id="config-2">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>disallowEmptyFunctions</code></td><td>bool</td><td>Whether to disallow empty block statements in function declarations, arrow functions,<br>getters, setters, and methods.</td></tr>
<tr><td><code>allowEmptyCatch</code></td><td>bool</td><td>Whether to allow empty <code>catch</code> clauses without a comment.</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">{}
</code></pre>
<pre><code class="language-js">if (foo) {}
</code></pre>
<pre><code class="language-js">do { } while (scoot)
</code></pre>
<pre><code class="language-js">for(let i = 5; i &lt; 10; i++) {}
</code></pre>
<pre><code class="language-js">switch (foo) {}
</code></pre>
<pre><code class="language-js">switch (foo /* bar */) {}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">{ /* sike you thought it was empty */ }
</code></pre>
<pre><code class="language-js">{
// foo   
}
</code></pre>
<pre><code class="language-js">if (foo) { /* */ }
</code></pre>
<pre><code class="language-js">switch (bar) { /* */ }
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_empty.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-extra-boolean-cast" id="no-extra-boolean-cast">no-extra-boolean-cast</a></h1>
<p>Disallow unnecessary boolean casts.</p>
<p>In contexts where expression will be coerced to a <code>Boolean</code> (e.g. <code>if</code>),
casting to a boolean (using <code>!!</code> or <code>Boolean(expr)</code>) is unnecessary.</p>
<h2><a class="header" href="#invalid-code-examples-4" id="invalid-code-examples-4">Invalid Code Examples</a></h2>
<pre><code class="language-js">if (!!foo) {}
while (!!foo) {}

var foo = !!!bar;
var foo = Boolean(!!bar);
</code></pre>
<h2><a class="header" href="#config-3" id="config-3">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enforceForLogicalOperands</code></td><td>bool</td><td>If this option is <code>true</code>, this rule will also check for unnecessary boolean<br>cast inside logical expression, which is disabled by default.</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">if (!!foo) {}
</code></pre>
<pre><code class="language-js">do {} while (!!foo)
</code></pre>
<pre><code class="language-js">while (!!foo) {}
</code></pre>
<pre><code class="language-js">!!foo ? bar : baz
</code></pre>
<pre><code class="language-js">for (; !!foo;) {}
</code></pre>
<pre><code class="language-js">!!!foo
</code></pre>
<pre><code class="language-js">Boolean(!!foo)
</code></pre>
<pre><code class="language-js">new Boolean(!!foo)
</code></pre>
<pre><code class="language-js">if (Boolean(foo)) {}
</code></pre>
<pre><code class="language-js">do {} while (Boolean(foo))
</code></pre>
<pre><code class="language-js">while (Boolean(foo)) {}
</code></pre>
<pre><code class="language-js">Boolean(foo) ? bar : baz
</code></pre>
<pre><code class="language-js">for (; Boolean(foo);) {}
</code></pre>
<pre><code class="language-js">!Boolean(foo)
</code></pre>
<pre><code class="language-js">!Boolean(foo &amp;&amp; bar)
</code></pre>
<pre><code class="language-js">!Boolean(foo + bar)
</code></pre>
<pre><code class="language-js">!Boolean(+foo)
</code></pre>
<pre><code class="language-js">!Boolean(foo())
</code></pre>
<pre><code class="language-js">!Boolean(foo = bar)
</code></pre>
<pre><code class="language-js">!Boolean(...foo);
</code></pre>
<pre><code class="language-js">!Boolean(foo, bar());
</code></pre>
<pre><code class="language-js">!Boolean((foo, bar()));
</code></pre>
<pre><code class="language-js">!Boolean();
</code></pre>
<pre><code class="language-js">!(Boolean());
</code></pre>
<pre><code class="language-js">if (!Boolean()) { foo() }
</code></pre>
<pre><code class="language-js">while (!Boolean()) { foo() }
</code></pre>
<pre><code class="language-js">if (Boolean()) { foo() }
</code></pre>
<pre><code class="language-js">while (Boolean()) { foo() }
</code></pre>
<pre><code class="language-js">Boolean(Boolean(foo))
</code></pre>
<pre><code class="language-js">Boolean(!!foo, bar)
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">Boolean(bar, !!baz);
</code></pre>
<pre><code class="language-js">var foo = !!bar;
</code></pre>
<pre><code class="language-js">function foo() { return !!bar; }
</code></pre>
<pre><code class="language-js">var foo = bar() ? !!baz : !!bat
</code></pre>
<pre><code class="language-js">for(!!foo;;) {}
</code></pre>
<pre><code class="language-js">for(;; !!foo) {}
</code></pre>
<pre><code class="language-js">var foo = Boolean(bar);
</code></pre>
<pre><code class="language-js">function foo() { return Boolean(bar); }
</code></pre>
<pre><code class="language-js">var foo = bar() ? Boolean(baz) : Boolean(bat)
</code></pre>
<pre><code class="language-js">for(Boolean(foo);;) {}
</code></pre>
<pre><code class="language-js">for(;; Boolean(foo)) {}
</code></pre>
<pre><code class="language-js">if (new Boolean(foo)) {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_extra_boolean_cast.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-extra-semi" id="no-extra-semi">no-extra-semi</a></h1>
<p>Disallow unneeded semicolons.</p>
<p>Unneeded semicolons are often caused by typing mistakes, while this is not an error, it
can cause confusion when reading the code. This rule disallows empty statements (extra semicolons).</p>
<h2><a class="header" href="#invalid-code-examples-5" id="invalid-code-examples-5">Invalid Code Examples</a></h2>
<pre><code class="language-js">if (foo) {
    ;
}
</code></pre>
<pre><code class="language-js">class Foo {
    constructor() {};
}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">;
</code></pre>
<pre><code class="language-js">if (foo) {
  ;
}
</code></pre>
<pre><code class="language-js">class Foo {
  ;
}
</code></pre>
<pre><code class="language-js">class Foo extends Bar {
  constructor() {};
}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">class Foo {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_extra_semi.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-inner-declarations" id="no-inner-declarations">no-inner-declarations</a></h1>
<p>Disallow variable and function declarations in nested blocks.</p>
<p>Prior to ECMAScript 6, function declarations were only allowed in the first level of a program
or the body of another function, although parsers sometimes incorrectly accept it. This rule only applies to
function declarations, not function expressions.</p>
<h2><a class="header" href="#invalid-code-examples-6" id="invalid-code-examples-6">Invalid Code Examples</a></h2>
<pre><code class="language-js">function foo() {
    if (bar) {
        // Move this to foo's body, outside the if statement
        function bar() {}
    }
}
</code></pre>
<pre><code class="language-js">if (bar) {
    var foo = 5;
}
</code></pre>
<h2><a class="header" href="#correct-code-examples-7" id="correct-code-examples-7">Correct Code Examples</a></h2>
<pre><code class="language-js">function foo() {}

var bar = 5;
</code></pre>
<h2><a class="header" href="#config-4" id="config-4">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>disallowed</code></td><td>Vec &lt; String &gt;</td><td>What declarations to disallow in nested blocks, it can include two possible options:<br>&quot;functions&quot; and &quot;variables&quot;, you can include either or, or both. Disallows only functions<br>by default.</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">if (test) { function doSomething() { } }
</code></pre>
<pre><code class="language-js">if (foo)  function f(){}
</code></pre>
<pre><code class="language-js">function bar() { if (foo) function f(){}; }
</code></pre>
<pre><code class="language-js">function doSomething() { do { function somethingElse() { } } while (test); }
</code></pre>
<pre><code class="language-js">(function() { if (test) { function doSomething() { } } }());
</code></pre>
<pre><code class="language-js">if (foo){ function f(){ if(bar){ var a; } } }
</code></pre>
<pre><code class="language-js">if (foo) function f(){ if(bar) var a; }
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">function doSomething() { }
</code></pre>
<pre><code class="language-js">if (test) { let x = 1; }
</code></pre>
<pre><code class="language-js">if (test) { const x = 1; }
</code></pre>
<pre><code class="language-js">export const foo = [];
export function bar() {}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_inner_declarations.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-irregular-whitespace" id="no-irregular-whitespace">no-irregular-whitespace</a></h1>
<p>Disallow weird/irregular whitespace.</p>
<p>ECMAScript allows a wide selection of unicode whitespace, they are however known to
cause issues with various parsers, therefore they should never be used.</p>
<p>A lot of the whitespace is invisible, therefore is hard to detect, it may have been inserted
by accident.</p>
<p>Whitespace such as line separator causes issues since line separators are not valid JSON which
may cause many issues.</p>
<p>This rule disallows the following whitespace:</p>
<pre><code class="language-text">\u000B - Line Tabulation (\v) - &lt;VT&gt;
\u000C - Form Feed (\f) - &lt;FF&gt;
\u00A0 - No-Break Space - &lt;NBSP&gt;
\u0085 - Next Line
\u1680 - Ogham Space Mark
\u180E - Mongolian Vowel Separator - &lt;MVS&gt;
\ufeff - Zero Width No-Break Space - &lt;BOM&gt;
\u2000 - En Quad
\u2001 - Em Quad
\u2002 - En Space - &lt;ENSP&gt;
\u2003 - Em Space - &lt;EMSP&gt;
\u2004 - Tree-Per-Em
\u2005 - Four-Per-Em
\u2006 - Six-Per-Em
\u2007 - Figure Space
\u2008 - Punctuation Space - &lt;PUNCSP&gt;
\u2009 - Thin Space
\u200A - Hair Space
\u200B - Zero Width Space - &lt;ZWSP&gt;
\u2028 - Line Separator
\u2029 - Paragraph Separator
\u202F - Narrow No-Break Space
\u205f - Medium Mathematical Space
\u3000 - Ideographic Space
</code></pre>
<h2><a class="header" href="#config-5" id="config-5">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>skipStrings</code></td><td>bool</td><td>Whether to allow any whitespace in string literals (true by default)</td></tr>
<tr><td><code>skipComments</code></td><td>bool</td><td>Whether to allow any whitespace in comments (false by default)</td></tr>
<tr><td><code>skipRegex</code></td><td>bool</td><td>Whether to allow any whitespace in regular expressions (false by default)</td></tr>
<tr><td><code>skipTemplates</code></td><td>bool</td><td>Whether to allow any whitespace in template literals (false by default)</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">var any  = 'thing';
</code></pre>
<pre><code class="language-js">var any  = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any ﻿ = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any   = 'thing';
</code></pre>
<pre><code class="language-js">var any 　 = 'thing';
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">'\u{000B}';
</code></pre>
<pre><code class="language-js">'\u{000C}';
</code></pre>
<pre><code class="language-js">'\u{0085}';
</code></pre>
<pre><code class="language-js">'\u{00A0}';
</code></pre>
<pre><code class="language-js">'\u{180E}';
</code></pre>
<pre><code class="language-js">'\u{feff}';
</code></pre>
<pre><code class="language-js">'\u{2000}';
</code></pre>
<pre><code class="language-js">'\u{2001}';
</code></pre>
<pre><code class="language-js">'\u{2002}';
</code></pre>
<pre><code class="language-js">'\u{2003}';
</code></pre>
<pre><code class="language-js">'\u{2004}';
</code></pre>
<pre><code class="language-js">'\u{2005}';
</code></pre>
<pre><code class="language-js">'\u{2006}';
</code></pre>
<pre><code class="language-js">'\u{2007}';
</code></pre>
<pre><code class="language-js">'\u{2008}';
</code></pre>
<pre><code class="language-js">'\u{2009}';
</code></pre>
<pre><code class="language-js">'\u{200A}';
</code></pre>
<pre><code class="language-js">'\u{200B}';
</code></pre>
<pre><code class="language-js">'\u{2028}';
</code></pre>
<pre><code class="language-js">'\u{2029}';
</code></pre>
<pre><code class="language-js">'\u{202F}';
</code></pre>
<pre><code class="language-js">'\u{205f}';
</code></pre>
<pre><code class="language-js">'\u{3000}';
</code></pre>
<pre><code class="language-js">'';
</code></pre>
<pre><code class="language-js">'';
</code></pre>
<pre><code class="language-js">'';
</code></pre>
<pre><code class="language-js">' ';
</code></pre>
<pre><code class="language-js">'᠎';
</code></pre>
<pre><code class="language-js">'﻿';
</code></pre>
<pre><code class="language-js">' ';
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_irregular_whitespace.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-prototype-builtins" id="no-prototype-builtins">no-prototype-builtins</a></h1>
<p>Disallow direct use of <code>Object.prototype</code> builtins directly.</p>
<p>ES 5.1 added <code>Object.create</code> which allows creation of object with a custom prototype. This
pattern is frequently used for objects used as Maps. However this pattern can lead to errors
if something else relies on prototype properties/methods.</p>
<p>Moreover, the methods could be shadowed, this can lead to random bugs and denial of service
vulnerabilities. For example, calling <code>hasOwnProperty</code> directly on parsed json could lead to vulnerabilities.
Instead, you should use get the method directly from the object using <code>Object.prototype.prop.call(item, args)</code>.</p>
<h2><a class="header" href="#invalid-code-examples-7" id="invalid-code-examples-7">Invalid Code Examples</a></h2>
<pre><code class="language-js">var bar = foo.hasOwnProperty(&quot;bar&quot;);

var bar = foo.isPrototypeOf(bar);

var bar = foo.propertyIsEnumerable(&quot;bar&quot;);
</code></pre>
<h2><a class="header" href="#correct-code-examples-8" id="correct-code-examples-8">Correct Code Examples</a></h2>
<pre><code class="language-js">var bar = Object.prototype.hasOwnProperty.call(foo, &quot;bar&quot;);

var bar = Object.prototype.isPrototypeOf.call(foo, bar);

var bar = Object.propertyIsEnumerable.call(foo, &quot;bar&quot;);
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">foo.hasOwnProperty(&quot;bar&quot;);
</code></pre>
<pre><code class="language-js">foo.isPrototypeOf(&quot;bar&quot;);
</code></pre>
<pre><code class="language-js">foo.propertyIsEnumberable(&quot;bar&quot;);
</code></pre>
<pre><code class="language-js">foo.bar.baz.hasOwnProperty(&quot;bar&quot;);
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">Object.prototype.hasOwnProperty.call(foo, 'bar');
</code></pre>
<pre><code class="language-js">Object.prototype.isPrototypeOf.call(foo, 'bar');
</code></pre>
<pre><code class="language-js">Object.prototype.propertyIsEnumberable.call(foo, 'bar');
</code></pre>
<pre><code class="language-js">Object.prototype.hasOwnProperty.apply(foo, ['bar']);
</code></pre>
<pre><code class="language-js">Object.prototype.isPrototypeOf.apply(foo, ['bar']);
</code></pre>
<pre><code class="language-js">Object.prototype.propertyIsEnumberable.apply(foo, ['bar']);
</code></pre>
<pre><code class="language-js">hasOwnProperty(foo, 'bar');
</code></pre>
<pre><code class="language-js">isPrototypeOf(foo, 'bar');
</code></pre>
<pre><code class="language-js">propertyIsEnumberable(foo, 'bar');
</code></pre>
<pre><code class="language-js">({}.hasOwnProperty.call(foo, 'bar'));
</code></pre>
<pre><code class="language-js">({}.isPrototypeOf.call(foo, 'bar'));
</code></pre>
<pre><code class="language-js">({}.propertyIsEnumberable.call(foo, 'bar'));
</code></pre>
<pre><code class="language-js">({}.hasOwnProperty.apply(foo, ['bar']));
</code></pre>
<pre><code class="language-js">({}.isPrototypeOf.apply(foo, ['bar']));
</code></pre>
<pre><code class="language-js">({}.propertyIsEnumberable.apply(foo, ['bar']));
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_prototype_builtins.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-setter-return" id="no-setter-return">no-setter-return</a></h1>
<p>Disallow setters to return values.</p>
<p>Setters cannot return values. To be more precise, a setter that returns a value is not treated as an error, but we
cannot use the returned value at all. Thus, if you write a setter that will return something, it is most likely
either completely unnecessary or a possible error.</p>
<p>Note that <code>return</code> without a value is allowed because it is considered a control flow statement.</p>
<p>This rule checks setters in:</p>
<ul>
<li>Object literals</li>
<li>Class declarations and class expressions</li>
<li>Property descriptors in <code>Object.create</code>, <code>Object.defineProperty</code>, <code>Object.defineProperties</code>, and <code>Reflect.defineProperty</code></li>
</ul>
<h2><a class="header" href="#incorrect-code-examples-6" id="incorrect-code-examples-6">Incorrect code examples</a></h2>
<pre><code class="language-js">let foo = {
    set a(value) {
        this.val = value;
        // The setter always returns a value
        return value;
    }
};

class Foo {
    set a(value) {
        this.val = value;
        // The setter always returns a value
        return this.val;
    }
}

const Bar = class {
    static set a(value) {
        if (value &lt; 0) {
            this.val = 0;
            // The setter returns `0` if the value is negative
            return 0;
        }
        this.val = value;
    }
};

Object.defineProperty(foo, &quot;bar&quot;, {
    set(value) {
        if (value &lt; 0) {
            // The setter returns `false` if the value is negative
            return false;
        }
        this.val = value;
    }
});
</code></pre>
<h2><a class="header" href="#correct-code-examples-9" id="correct-code-examples-9">Correct code examples</a></h2>
<pre><code class="language-js">let foo = {
    set a(value) {
        this.val = value;
    }
};

class Foo {
    set a(value) {
        this.val = value;
    }
}

const Bar = class {
    static set a(value) {
        if (value &lt; 0) {
            this.val = 0;
            // Returning without a value is allowed
            return;
        }
        this.val = value;
    }
};

Object.defineProperty(foo, &quot;bar&quot;, {
    set(value) {
        if (value &lt; 0) {
            // Throwing an error is also allowed
            throw new Error(&quot;Negative value is not allowed.&quot;);
        }
        this.val = value;
    }
});
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">let foo = {
    set bar(val) {
        return 42;
    }
};
</code></pre>
<pre><code class="language-js">let bar = {
    set foo(val) {
        if (bar) {
            return 42;
        }
    }
};
</code></pre>
<pre><code class="language-js">let bar = {
    set foo(val) {
        switch (bar) {
            case 5:
            case 6:
            if (bar) {
                return 42;
            }
        }
    }
};
</code></pre>
<pre><code class="language-js">let bar = {
    set foo(val) {
        if (bar) {

        } else {
            return 42;
        }
    }
};
</code></pre>
<pre><code class="language-js">class Foo {
    set bar(val) {
        return 42;
    }
}
</code></pre>
<pre><code class="language-js">let Foo = class {
    set bar(val) {
        return 42;
    }
};
</code></pre>
<pre><code class="language-js">Object.create(null, {
    foo: {
        set(val) {
            return 42;
        }
    }
});
</code></pre>
<pre><code class="language-js">Object.defineProperty(foo, 'bar', {
    set(val) {
        return 42;
    }
});
</code></pre>
<pre><code class="language-js">Object.defineProperties(foo, 'bar', {
    set(val) {
        return 42;
    }
});
</code></pre>
<pre><code class="language-js">Reflect.defineProperties(foo, 'bar', {
    set(val) {
        return 42;
    }
});
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">({ set foo(val) { return; } })
</code></pre>
<pre><code class="language-js">({ set foo(val) { if (val) { return; } } })
</code></pre>
<pre><code class="language-js">class A { set foo(val) { return; } }
</code></pre>
<pre><code class="language-js">(class { set foo(val) { if (val) { return; } else { return; } return; } })
</code></pre>
<pre><code class="language-js">class A { set foo(val) { try {} catch(e) { return; } } }
</code></pre>
<pre><code class="language-js">Object.defineProperty(foo, 'bar', { set(val) { return; } })
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_setter_return.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-sparse-arrays" id="no-sparse-arrays">no-sparse-arrays</a></h1>
<p>Disallow sparse arrays.</p>
<p>Sparse arrays are arrays with empty slots, they are denoted by extra commas, such as:</p>
<pre><code class="language-js">let foo = [,,];
let foo = [bar,, baz];
</code></pre>
<p>Sparse elements will be filled in as undefined elements and count towards array length.
This is often a typo or is hard to comprehend and an explicit method should be used.</p>
<h2><a class="header" href="#invalid-code-examples-8" id="invalid-code-examples-8">Invalid Code Examples</a></h2>
<pre><code class="language-js">let foo = [,];
let bar = [foo,, bar];
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">[,]
</code></pre>
<pre><code class="language-js">[...2,, 3]
</code></pre>
<pre><code class="language-js">[4,,]
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">[1, 2]
</code></pre>
<pre><code class="language-js">[3,]
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_sparse_arrays.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-unexpected-multiline" id="no-unexpected-multiline">no-unexpected-multiline</a></h1>
<p>Disallow confusing newlines in expressions.</p>
<p>JavaScript has automatic semicolon insertion, where newlines end statements, however,
expressions can often span across newlines, therefore it can become a bit confusing at times
and ambiguous. Take the following as an example:</p>
<pre><code class="language-js">let foo = bar
/bar/g.test(&quot;foo&quot;);
</code></pre>
<p>you would expect this to be a variable declaration and then a regex test, however, it is actually
a division expression as such: `(bar / bar) / (g.test(&quot;foo&quot;)).
This rule is aimed at preventing ambiguous and buggy expressions such like these. It disallows
ambiguous tagged templates, property accesses, function calls, and division expressions.</p>
<h2><a class="header" href="#invalid-code-examples-9" id="invalid-code-examples-9">Invalid Code Examples</a></h2>
<pre><code class="language-js">var foo = bar
(1 || 2).baz();

var foo = 'bar'
[1, 2, 3].forEach(addNumber);

let x = function() {}
`foo`

let x = function() {}
x
`bar`

let x = foo
/regex/g.test(bar)
</code></pre>
<h2><a class="header" href="#correct-code-examples-10" id="correct-code-examples-10">Correct Code Examples</a></h2>
<pre><code class="language-js">var foo = bar;
(1 || 2).baz();

var foo = 'bar';
[1, 2, 3].forEach(addNumber);

let x = function() {};
`foo`

let x = function() {};
x;
`bar`

let x = foo;
/regex/g.test(bar)
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">var a = b
(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = (a || b)
(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = (a || b)
(x).doSomething()
</code></pre>
<pre><code class="language-js">var a = b
[a, b, c].forEach(doSomething)
</code></pre>
<pre><code class="language-js">var a = b
(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = b
[a, b, c].forEach(doSomething)
</code></pre>
<pre><code class="language-js">let x = function() {}
`hello`
</code></pre>
<pre><code class="language-js">let x = function() {}
x
`hello`
</code></pre>
<pre><code class="language-js">x
.y
z
`Invalid Test Case`
</code></pre>
<pre><code class="language-js">foo
/ bar /gym
</code></pre>
<pre><code class="language-js">foo
/ bar /g
</code></pre>
<pre><code class="language-js">foo
/ bar /g.test(baz)
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">(x || y).aFunction()
</code></pre>
<pre><code class="language-js">[a, b, c].forEach(doSomething)
</code></pre>
<pre><code class="language-js">var a = b;
(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = b
;(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = b
void (x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = b;
[1, 2, 3].forEach(console.log)
</code></pre>
<pre><code class="language-js">var a = b
void [1, 2, 3].forEach(console.log)
</code></pre>
<pre><code class="language-js">&quot;abc\
(123)&quot;
</code></pre>
<pre><code class="language-js">var a = (
(123)
)
</code></pre>
<pre><code class="language-js">f(
(x)
)
</code></pre>
<pre><code class="language-js">(
function () {}
)[1]
</code></pre>
<pre><code class="language-js">let x = function() {};
`hello`
</code></pre>
<pre><code class="language-js">let x = function() {}
x `hello`
</code></pre>
<pre><code class="language-js">String.raw `Hi
${2+3}!`;
</code></pre>
<pre><code class="language-js">x
.y
z `Valid Test Case`
</code></pre>
<pre><code class="language-js">f(x
)`Valid Test Case`
</code></pre>
<pre><code class="language-js">x.
y `Valid Test Case`
</code></pre>
<pre><code class="language-js">(x
)`Valid Test Case`
</code></pre>
<pre><code class="language-js">foo
/ bar /2
</code></pre>
<pre><code class="language-js">foo
/ bar / mgy
</code></pre>
<pre><code class="language-js">foo
/ bar /
gym
</code></pre>
<pre><code class="language-js">foo
/ bar
/ ygm
</code></pre>
<pre><code class="language-js">foo
/ bar /GYM
</code></pre>
<pre><code class="language-js">foo
/ bar / baz
</code></pre>
<pre><code class="language-js">foo /bar/g
</code></pre>
<pre><code class="language-js">foo
/denominator/
2
</code></pre>
<pre><code class="language-js">foo
/ /abc/
</code></pre>
<pre><code class="language-js">5 / (5
/ 5)
</code></pre>
<pre><code class="language-js">var a = b
?.(x || y).doSomething()
</code></pre>
<pre><code class="language-js">var a = b
?.[a, b, c].forEach(doSomething)
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_unexpected_multiline.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-unsafe-finally" id="no-unsafe-finally">no-unsafe-finally</a></h1>
<p>Forbid the use of unsafe control flow statements in try and catch blocks.</p>
<p>JavaScript suspends any running control flow statements inside of <code>try</code> and <code>catch</code> blocks until
<code>finally</code> is done executing. This means that any control statements such as <code>return</code>, <code>throw</code>, <code>break</code>,
and <code>continue</code> which are used inside of a <code>finally</code> will override any control statements in <code>try</code> and <code>catch</code>.
This is almost always unexpected behavior.</p>
<h2><a class="header" href="#incorrect-code-examples-7" id="incorrect-code-examples-7">Incorrect Code Examples</a></h2>
<pre><code class="language-js">// We expect 10 to be returned, but 5 is actually returned
function foo() {
    try {
        return 10;
    //  ^^^^^^^^^ this statement is executed, but actually returning is paused...
    } finally {
        return 5;
    //  ^^^^^^^^^ ...finally is executed, and this statement returns from the function, **the previous is ignored**
    }
}
foo() // 5
</code></pre>
<p>Throwing errors inside try statements</p>
<pre><code class="language-js">// We expect an error to be thrown, then 5 to be returned, but the error is not thrown
function foo() {
    try {
        throw new Error(&quot;bar&quot;);
    //  ^^^^^^^^^^^^^^^^^^^^^^^ this statement is executed but throwing the error is paused...
    } finally {
        return 5;
    //  ^^^^^^^^^ ...we expect the error to be thrown and then for 5 to be returned,
    //  but 5 is returned early, **the error is not thrown**.
    }
}
foo() // 5
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">try {
    throw A;
} finally {
    return;
}
</code></pre>
<pre><code class="language-js">try {
    throw new Error();
} catch {

} finally {
    continue;
}
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">try {
    throw A;
} finally {
    if (false) {
        return true;
    }
}
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_unsafe_finally.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#no-unsafe-negation" id="no-unsafe-negation">no-unsafe-negation</a></h1>
<p>Deny the use of <code>!</code> on the left hand side of an <code>instanceof</code> or <code>in</code> expression where it is ambiguous.</p>
<p>JavaScript precedence is higher for logical not than it is for in or instanceof. Oftentimes you see
expressions such as <code>!foo instanceof bar</code>, which most of the times produces unexpected behavior.
precedence will group the expressions like <code>(!foo) instanceof bar</code>. Most of the times the developer expects
the expression to check if <code>foo</code> is not an instance of <code>bar</code> however.</p>
<h2><a class="header" href="#incorrect-code-examples-8" id="incorrect-code-examples-8">Incorrect Code Examples</a></h2>
<pre><code class="language-js">if (!foo instanceof String) {

}
</code></pre>
<pre><code class="language-js">if (!bar in {}) {

}
</code></pre>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">!foo in bar
</code></pre>
<pre><code class="language-js">![5] instanceof !4
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
 If this is intended behavior, you can wrap the expression
```js
(!foo) instanceof bar
```
<pre><code class="language-js">key in bar
</code></pre>
<pre><code class="language-js">bar instanceof bar
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/no_unsafe_negation.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#use-isnan" id="use-isnan">use-isnan</a></h1>
<p>Disallow incorrect comparisons against <code>NaN</code>.</p>
<p><code>NaN</code> is a special <code>Number</code> value used to represent &quot;not a number&quot; results in calculations.
This value is specified in the IEEE Standard for Binary Floating-Point-Arithmetic.</p>
<p>In JavaScript, <code>NaN</code> is unique, it is not equal to anything, including itself! therefore
any comparisons to it will either always yield <code>true</code> or <code>false</code>. Therefore you should
use <code>isNaN(/* num */)</code> instead to test if a value is <code>NaN</code>. This rule is aimed at removing this footgun.</p>
<h2><a class="header" href="#invalid-code-examples-10" id="invalid-code-examples-10">Invalid Code Examples</a></h2>
<pre><code class="language-js">if (foo == NaN) {
    // unreachable
}

if (NaN != NaN) {
    // always runs
}
</code></pre>
<h2><a class="header" href="#correct-code-examples-11" id="correct-code-examples-11">Correct Code Examples</a></h2>
<pre><code class="language-js">if (isNaN(foo)) {
    /* */
}

if (!isNaN(foo)) {
    /* */
}
</code></pre>
<h2><a class="header" href="#config-6" id="config-6">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enforceForSwitchCase</code></td><td>bool</td><td>Switch statements use <code>===</code> internally to match an expression, therefore <code>switch (NaN)</code> and <code>case NaN</code> will never match.<br>This rule disables uses like that which are always incorrect (true by default)</td></tr>
<tr><td><code>enforceForIndexOf</code></td><td>bool</td><td>Index functions like <code>indexOf</code> and <code>lastIndexOf</code> use <code>===</code> internally, therefore matching them against <code>NaN</code> will always<br>yield <code>-1</code>. This option disallows using <code>indexOf(NaN)</code> and <code>lastIndexOf(NaN)</code> (false by default)</td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">123 == NaN;
</code></pre>
<pre><code class="language-js">123 === NaN;
</code></pre>
<pre><code class="language-js">NaN === &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">NaN == &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">123 != NaN;
</code></pre>
<pre><code class="language-js">123 !== NaN;
</code></pre>
<pre><code class="language-js">NaN !== &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">NaN != &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">NaN &lt; &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">&quot;abc&quot; &lt; NaN;
</code></pre>
<pre><code class="language-js">NaN &gt; &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">&quot;abc&quot; &gt; NaN;
</code></pre>
<pre><code class="language-js">NaN &lt;= &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">&quot;abc&quot; &lt;= NaN;
</code></pre>
<pre><code class="language-js">NaN &gt;= &quot;abc&quot;;
</code></pre>
<pre><code class="language-js">&quot;abc&quot; &gt;= NaN;
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">var x = NaN;
</code></pre>
<pre><code class="language-js">isNaN(NaN) === true;
</code></pre>
<pre><code class="language-js">isNaN(123) !== true;
</code></pre>
<pre><code class="language-js">Number.isNaN(NaN) === true;
</code></pre>
<pre><code class="language-js">Number.isNaN(123) !== true;
</code></pre>
<pre><code class="language-js">foo(NaN + 1);
</code></pre>
<pre><code class="language-js">foo(1 + NaN);
</code></pre>
<pre><code class="language-js">foo(NaN - 1)
</code></pre>
<pre><code class="language-js">foo(1 - NaN)
</code></pre>
<pre><code class="language-js">foo(NaN * 2)
</code></pre>
<pre><code class="language-js">foo(2 * NaN)
</code></pre>
<pre><code class="language-js">foo(NaN / 2)
</code></pre>
<pre><code class="language-js">foo(2 / NaN)
</code></pre>
<pre><code class="language-js">var x; if (x = NaN) { }
</code></pre>
<pre><code class="language-js">foo.indexOf(NaN)
</code></pre>
<pre><code class="language-js">foo.lastIndexOf(NaN)
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/use_isnan.rs">Source</a></p>
<!--
 generated docs file, do not edit by hand, see xtask/docgen 
-->
<h1><a class="header" href="#valid-typeof" id="valid-typeof">valid-typeof</a></h1>
<p>Enforce the use of valid string literals in a <code>typeof</code> comparison.</p>
<p><code>typeof</code> can only return a small set of strings, <code>undefined</code>, <code>object</code>,
<code>boolean</code>, <code>number</code>, <code>string</code> or <code>function</code>, and if you provide
an invalid value, it's most likely a typo, and the comparison
will always return <code>false</code>.
This behaviour will be denied by this rule.</p>
<h2><a class="header" href="#invalid-code-examples-11" id="invalid-code-examples-11">Invalid Code Examples</a></h2>
<pre><code class="language-js">typeof foo === &quot;strnig&quot;
typeof foo == &quot;undefimed&quot;
typeof bar != &quot;nunber&quot;
typeof bar !== &quot;fucntion&quot;
</code></pre>
<h2><a class="header" href="#config-7" id="config-7">Config</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>requireStringLiterals</code></td><td>bool</td><td>* If this option is <code>true</code>, <code>typeof</code> expression can only be compared<br>* to valid string literals, or other <code>typeof</code> expressions, but<br>* can not be compared to any other value.<br></td></tr>
</tbody></table>
<details>
 <summary> More incorrect examples </summary>
<pre><code class="language-js">typeof foo === &quot;strnig&quot;
</code></pre>
<pre><code class="language-js">typeof foo == &quot;undefimed&quot;
</code></pre>
<pre><code class="language-js">typeof bar != &quot;nunber&quot;
</code></pre>
<pre><code class="language-js">typeof bar !== &quot;fucntion&quot;
</code></pre>
</details><br>
<details>
 <summary> More correct examples </summary>
<pre><code class="language-js">typeof foo === &quot;string&quot;
</code></pre>
<pre><code class="language-js">typeof bar == &quot;undefined&quot;
</code></pre>
<pre><code class="language-js">typeof foo === baz
</code></pre>
<pre><code class="language-js">typeof foo === 4
</code></pre>
<pre><code class="language-js">typeof bar === typeof qux
</code></pre>
</details>
<p><a href="https://github.com/RDambrosio016/RSLint/tree/master/crates/rslint_core/src/groups/errors/valid_typeof.rs">Source</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
